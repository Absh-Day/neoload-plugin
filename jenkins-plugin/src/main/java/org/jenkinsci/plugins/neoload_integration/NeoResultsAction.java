package org.jenkinsci.plugins.neoload_integration;

import hudson.FilePath;
import hudson.model.Action;
import hudson.model.AbstractBuild;
import hudson.model.Run.Artifact;
import hudson.remoting.VirtualChannel;

import java.io.File;
import java.io.IOException;
import java.io.Serializable;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.Iterator;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;

import org.codehaus.plexus.util.FileUtils;

/** This class integrates with the side panel of the specific run of a job. The side panel consists of the navigation links on the left.
 * 
 * Listens for the AbstractBuild so it can be referenced later. */
public class NeoResultsAction implements Action, Serializable {

	/** Generated. */
	private static final long serialVersionUID = 5761371163151810276L;

	/** This tag is found in certain pages generated by NeoLoad. */
	public static final String TAG_HTML_GENERATED_BY_NEOLOAD = "#HTML Report Generated by NeoLoad#";

	/** This is added to a file to mark whether the styles have been applied or not. */
	private static final String COMMENT_APPLIED_STYLE = "<!-- NeoLoad Jenkins plugin applied style -->";

	/** This is added to a file to mark whether the styles have been applied or not. */
	private static final String COMMENT_CSS_APPLIED_STYLE = "/* NeoLoad Jenkins plugin applied style */";

	/** The current build. */
	private final AbstractBuild<?, ?> build;

	/** True if the report file is found without any issues. This allows us to only show the link when the report file is found. */
	private Boolean foundReportFile = null;
	
	/** If true then this instance was created immediately after a build. If false the build existed already. 
	 * This covers when the plugin is uninstalled and reinstalled. */
	private boolean processingForTheFirstTime;

	/** Log various messages. */
	private static final Logger LOGGER = Logger.getLogger(NeoResultsAction.class.getName());

	/** @param target
	 * @param processingForTheFirstTime */
	public NeoResultsAction(final AbstractBuild<?, ?> target, final boolean processingForTheFirstTime) {
		super();
		this.build = target;
		this.processingForTheFirstTime = processingForTheFirstTime;
	}

	/**
	 * @param build
	 * @param processingForTheFirstTime
	 */
	public static void addActionIfNotExists(final AbstractBuild<?, ?> build, final boolean processingForTheFirstTime) {
		boolean alreadyAdded = false;
		for (final Action a: build.getActions()) {
			if (a instanceof NeoResultsAction) {
				alreadyAdded = true;
				break;
			}
		}

		if (!alreadyAdded) {
			final NeoResultsAction nra = new NeoResultsAction(build, processingForTheFirstTime);
			build.addAction(nra);
			LOGGER.log(Level.FINE, "Build " + build.number + ", Added action to build of job " +
					build.getProject().getDisplayName());
		}
	}

	/** For storing artifact data. */
	private static final class FileAndContent {
		/** Artifact data. */
		private final File file;

		/** URL to the artifact in Jenkins. */
		private final String href;

		/** Artifact data. */
		private String content = null;

		/** Constructor.
		 * 
		 * @param file
		 * @param href
		 * @param content
		 */
		public FileAndContent(final File file, final String href, final String content) {
			this.file = file;
			this.href = href;
			this.content = content;
		}

		/** The original modification date is kept in tact.
		 * @throws IOException
		 */
		public void writeFileContent() throws IOException {
			final long modDate = file.lastModified();
			if (file.canWrite()) {
				if (!file.delete()) {
					LOGGER.log(Level.SEVERE, "Error deleting file " + file.getAbsolutePath());
				}
				FileUtils.fileWrite(file.getAbsolutePath(), content);
				// keep the old modification date
				if (!file.setLastModified(modDate)) {
					LOGGER.log(Level.SEVERE, "Error updating (keeping original) modification date of file " + file.getAbsolutePath());
				}
			}
		}

		/**
		 * @return file.getParent();
		 */
		public String getFileParent() {
			return file.getParent();
		}
	}

	/**
	 * @return
	 * @throws IOException
	 */
	@SuppressWarnings("rawtypes")
	private FileAndContent findHtmlReportArtifact() {
		Artifact artifact = null;
		final Iterator<?> it = build.getArtifacts().iterator();
		String content = null;
		FileAndContent ac = null;

		// remove files that don't match
		while (it.hasNext()) {
			artifact = (Artifact) it.next();

			// if it's an html file
			if ((artifact.getFileName().length() > 4) &&
					("html".equalsIgnoreCase(artifact.getFileName().substring(artifact.getFileName().length() - 4)))) {

				// verify file contents
				content = null;
				try {
					content = FileUtils.fileRead(artifact.getFile().getAbsolutePath());
					if ((content != null) && (isNeoLoadHTMLReport(content))) {
						// verify that the file was created during the current build
						if (isFromTheCurrentBuild(artifact, content)) {
							processingForTheFirstTime = false; 
							ac = new FileAndContent(artifact.getFile(), artifact.getHref(), content);
							break;
						}
						processingForTheFirstTime = false; 
						LOGGER.log(Level.WARNING,
								"Build " + build.number + ", Found " + artifact.getFile().getAbsolutePath() + ", but it's too old to use. " +
										"Verify that the output directory matches the workspace directory. " +
										"Verify that the workspace directory is empty before launching the job. " +
								"Verify that clocks are synchronized between remote and local machines.");
					}
				} catch (final Exception e) {
					LOGGER.log(Level.FINE, "Error reading file. " + e.getMessage(), e);
				}
			}
		}

		return ac;
	}

	/**
	 * @param artifact
	 * @param fileContent 
	 * @return
	 * @throws IOException
	 * @throws InterruptedException
	 */
	private boolean isFromTheCurrentBuild(final Artifact artifact, String fileContent) throws IOException, InterruptedException {
		// if the artifact file exists and has the COMMENT_APPLIED_STYLE tag then the file is from the current build 
		// (because only files that have already been verified at least once by the plugin will have this comment tag).
		final String artifactFilePath = build.getArtifactsDir().getAbsolutePath() + File.separatorChar + artifact.relativePath;
		if (fileContent.contains(COMMENT_APPLIED_STYLE)) {
			LOGGER.log(Level.FINE, "Build " + build.number + ", Artifact file already has comment. Using for report link. " + artifactFilePath +
					", processingForTheFirstTime: " + processingForTheFirstTime);
			return true;
		}
		LOGGER.log(Level.FINE, "Build " + build.number + ", Artifact file without comment. No report link created. " + artifactFilePath +
				", processingForTheFirstTime: " + processingForTheFirstTime);
		
		if (!processingForTheFirstTime) {
			// if we're looking at old builds due to a new plugin installation then we don't check the file date of 
			// the workspace file because the workspace file is not related to old builds - it's related to the last successful output.
			return false;
		}
		
		// we now use the file date to verify that the file is new enough. (we verify that the file is from the current build and
		// not from an old build).
		final FilePath file = build.getWorkspace();
		// get the build date.
		final SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd kk:mm:ss");
		final Calendar buildStartTime = build.getTimestamp();
		
		final String workspaceFilePath = getWorkspaceFilePath(artifact);
		// get the file date of the workspace file from the remote machine because the file doesn't exist on the local machine.
		final long workspaceFileLastModifiedDate = file.act(new FileCallableForModifiedDate(workspaceFilePath));
		final Calendar workspaceFileCreateTime = Calendar.getInstance();
		workspaceFileCreateTime.setTime(new Date(workspaceFileLastModifiedDate));

		// Look at the date of the file on the workspace, not the artifact file. The artifact file is always new because it is copied after the job is run.
		// if the workspace file exists and has the right date then the file is from the current build.
		LOGGER.log(Level.FINE, "Build " + build.number + ", Start time: " + sdf.format(buildStartTime.getTime()) +  
				", Workspace file time: " + sdf.format(workspaceFileCreateTime.getTime()) + ", File: " + workspaceFilePath);
		
		// we do not check the buildEndTime here because the wrong workspace file time is returned when multiple jobs are scheduled
		// sequentially which makes comparing it to the buildEndTime useless. instead we only check the buildStart time and we check the 
		// processingForTheFirstTime variable above.
		if (buildStartTime.before(workspaceFileCreateTime)) {
			return true;
		}
		
		// the file is too old or doesn't exist. no output was created or the file in the workspace is from an old run.
		return false;
	}

	/**
	 * @param artifact
	 * @return
	 */
	private String getWorkspaceFilePath(final Artifact artifact) {
		final FilePath file = build.getWorkspace();
		final String workspaceDirectory = file.getRemote();
		final String workspaceFilePath = workspaceDirectory + File.separatorChar + artifact.relativePath;

		return workspaceFilePath;
	}

	/** Returns the file modification date of a file on a local or a remote machine. */
	static class FileCallableForModifiedDate implements FilePath.FileCallable<Long> {
		/** Generated. */
		private static final long serialVersionUID = 5191449389416826768L;

		private final String fullFilePath;

		public FileCallableForModifiedDate(final String fullFilePath) {
			this.fullFilePath = fullFilePath;
		}

		/* (non-Javadoc)
		 * @see hudson.FilePath.FileCallable#invoke(java.io.File, hudson.remoting.VirtualChannel)
		 */
		public Long invoke(final File f, final VirtualChannel channel) throws IOException, InterruptedException {
			final File myFile = new File(fullFilePath);
			if (!myFile.exists()) {
				LOGGER.fine("Can't find artifact file in the workspace. I'm looking for " + myFile.getPath());
				// return a date in 1970
				return 0L;
			}
			return myFile.lastModified();
		}
	}

	/**
	 * @param content
	 * @return true if the passed in content is the html file of a NeoLoad generated report
	 */
	private static boolean isNeoLoadHTMLReport(final String content) {
		if (content.contains(TAG_HTML_GENERATED_BY_NEOLOAD)) {
			return true;
		}

		// we could be dealing with an old version of NeoLoad, so we look for a likely NeoLoad file.
		if (content.startsWith("<html") &&
				(content.contains("<title")) &&
				(content.contains("_files/style.css")) &&
				(content.contains("<frameset")) &&
				(content.contains("_files/menu.html")) &&
				(content.contains("_files/summary.html"))) {

			return true;
		}

		return false;
	}

	/**
	 * @return
	 */
	public AbstractBuild<?, ?> getBuild() {
		return build;
	}

	/**
	 * @return
	 * @throws IOException
	 */
	public String getHtmlReportFilePath() {
		final FileAndContent ac = findHtmlReportArtifact();

		if (ac != null) {
			// append the style changes if it hasn't already been done
			if (!ac.content.contains(COMMENT_APPLIED_STYLE)) {
				applySpecialFormatting(ac);
			}

			foundReportFile = true;
			return ac.href;
		}

		foundReportFile = false;
		return null;
	}

	/** Fix the horizontal scrollbar by adding overflow-x: hidden in many places.
	 * @param ac
	 */
	private static void applySpecialFormatting(final FileAndContent ac) {
		try {
			// adjust the content.
			ac.content = ac.content.replaceAll(Matcher.quoteReplacement("id=\"menu\""), "id=\"menu\" style='overflow-x: hidden;' ");
			ac.content = ac.content.replaceAll(Matcher.quoteReplacement("id=\"content\""), "id=\"content\" style='overflow-x: hidden;' ");
			ac.content += COMMENT_APPLIED_STYLE;

			// write the content
			ac.writeFileContent();

			// find the menu.html
			String temp = ac.content.substring(ac.content.indexOf("src=\"") + 5);
			temp = temp.substring(0, temp.indexOf('\"'));
			final String menuLink = ac.getFileParent() + File.separatorChar + temp;
			String menuContent = FileUtils.fileRead(menuLink);
			menuContent = menuContent.replace(Matcher.quoteReplacement("body {"), "body {\noverflow-x: hidden;");
			menuContent += COMMENT_APPLIED_STYLE;
			if (!new File(menuLink).delete()) {
				LOGGER.log(Level.SEVERE, "Error deleting file " + menuLink);
			}
			FileUtils.fileWrite(menuLink, menuContent);

			// find the style.css
			temp = ac.content.substring(ac.content.indexOf("<link"), ac.content.indexOf(">", ac.content.indexOf("<link")));
			temp = temp.substring(temp.indexOf("href=") + 6, temp.length() - 1);
			final String styleLink = ac.getFileParent() + File.separatorChar + temp;
			String styleContent = FileUtils.fileRead(styleLink);
			styleContent = styleContent.replace(Matcher.quoteReplacement("body {"), "body {\noverflow-x: hidden;");
			styleContent += COMMENT_CSS_APPLIED_STYLE;
			new File(styleLink).delete();
			FileUtils.fileWrite(styleLink, styleContent);

		} catch (final IOException e) {
			// this operation is not important enough to throw an exception.
			LOGGER.log(Level.WARNING, "Couldn't add custom style to report files.");
		}
	}

	public String getDisplayName() {
		setFoundReportFile();
		if (!foundReportFile) {
			return null;
		}
		return "Performance Result";
	}

	public String getIconFileName() {
		setFoundReportFile();
		if (!foundReportFile) {
			return null;
		}
		return "/plugin/neoload-jenkins-plugin/images/neoload-cropped.png";
	}

	public String getUrlName() {
		setFoundReportFile();
		if (!foundReportFile) {
			return null;
		}
		return "neoload-report";
	}

	/** Set true if we can find the report file. */
	private void setFoundReportFile() {
		if (foundReportFile == null) {
			getHtmlReportFilePath();
		}
	}
}
